### 22/9/3
* 격리 4일차.
### 22/9/2
* 격리 3일차.
### 22/9/1
* 격리 2일차.
### 22/8/31
* 확진자 밀접접촉자로 분류되어 격리..
### 22/8/30
* 백준-25341(implementation) 시도 - 기존에 인공 신경망의 구조를 알고 있었기 때문에 구현은 빠르게 되었지만, 시간 복잡도에서 걸렸다. 계산을 간소화 하여 시간 복잡도를 줄여보자. > (ax+b)*c+d = acx+bc+d
### 22/8/29
* 개인정비시간 부족으로 하루 휴식.
### 22/8/28
* 백준-1826(sort) 완료 - 현재 위치에서 도달 가능한 모든 주유소를 heap에 push. 그 후 가장 연료를 많이 주는 주유소에서 주유. (이때 현 위치보다 앞에 있는 주유소일 경우 pos 를 그 주유소 위치로 만들고 그 거리만큼 연료에 마이너스. ∵ 한번 주유를 했음에도 불구하고 다음 주유소 혹은 목적지까지 도달이 불가능할 경우 지나쳤던 주유소에서 주유를 하게 될 수도 있으므로) 이때 주유할 수 있는 주유소가 heap에 하나도 없는 경우 -1 출력하고 종료. cf)https://fre2-dom.tistory.com/59
### 22/8/27
* 백준-1826(sort) 시도 - 잘못된 그리디 알고리즘을 사용해서 문제가 발생했다. cf)https://velog.io/@sunjoo9912/%EB%B0%B1%EC%A4%80-1826-%EC%97%B0%EB%A3%8C-%EC%B1%84%EC%9A%B0%EA%B8%B0 -> 현재까지 지나쳐온 주유소를 체크하는게 핵심이다. 연료가 부족하면 지금까지 지나쳐온 주유소중 가장 연료가 많았던 주유소의 연료량만큼 채우고 count+=1 하면 된다.
* [연등] 백준-1826(sort) 시도 - maxheap을 사용하여 구현했으나 구현실력이 아직 낮아 통과를 못하고 있다. cf)https://travelbeeee.tistory.com/492
### 22/8/26
* 백준-2457(sort) 시도 - 시간이 없어서 구현을 많이 못했다. 연등이나 다음날에 이어서 해보자.
* [연등] 백준-2457(sort) 완료 - 여러 엣지케이스를 하나하나 열심히 막아주었더니 성공했다. ~~그 대신 코드는 이렇게 푸는게 맞나 싶을 정도로 더러워졌다~~
* readme 날짜 내림차순으로 재정렬
### 22/8/25
* [연등] 백준-10800(sort) 완료 - 같은 크기, 다른 색의 공일 때 공의 개수를 카운트하는 로직은 단순히 각 공의 개수의 합을 1씩 제거함으로써 잘못된 누적합 계산을 해결했다. 그리고 hash를 적극 이용하자. 불필요한 이중 리스트는 hash의 키로 tuple을 사용하면 빠르고 가볍게 돌릴 수 있다. dict와 set을 손에 잘 익히자. 
### 22/8/24
* 이하 동일
### 22/8/23
* 사지방이 휴게공간으로 바뀌어 며칠간 이용을 못하게 되었다.
### 22/8/22
* 오늘은 휴식. 많이 바빴고 시간이 없었다.
### 22/8/21
* 백준-2473(sort) 최적화 - pypy3는 정말 빠르게 푸는데, python3 는 아슬아슬하게 시간 초과가 난다. 구글링해서 성공한 코드와 같은 알고리즘으로 만들어도 왜 내 경우는 시간초과인지 잘 모르겠다. 패스..
* 백준-13904(sort) 완료 - 깊이 생각하니 풀 수 있었다. 조금 특이한 방법으로 풀은 것 같긴 한데, 정석을 참고해보아야겠다.
* 백준-13904(sort) 추가 학습 완료 - 조금 더 정석에 가까운 알고리즘으로 다시 해결했다.
* 백준-2109(sort) 완료 - 13904와 큰 차이가 없는 문제였다.
* [연등] 백준-10800(sort) 시도 - 같은 크기, 다른 색의 공일 때 공의 개수를 카운트하는 로직에서 시간이 부족하여 완료하지 못했다. 다음 시간에 성공시켜야겠다.
### 22/8/20
* 백준-3649(sort) 완료 - 역시 큰 어려움 없이 풀었다. 문제에 테스트 케이스가 여러개였다는 것이 함정;
* 백준-14921(sort) 완료 - 투 포인터 정복. (정렬되어있다는 가정 하 / 차의 최소 : -> ->, 합의 최소 : -> <-, 합 혹은 차의 값 찾기 : 둘 다 가능하긴 함)
* 백준-5052(sort) 완료 - g4인데도 불구하고 매우 쉽게 풀었다..
* [연등] 백준-2473(sort) 완료 - 이것도 g3치고 pypy3로는 쉽게 풀렸으나, python3 로는 시간초과가 난다. 가장 이상적인 시간 복잡도(=O(N^2))로 처리한 것 같은데, 아무리 최적화해도 쉽게 해결되지 않았다.. 다음에도 계속 최적화 해보자.
### 22/8/19
* 백준-1744(sort) 완료 - 큰 어려움 없이 풀었으나, 논리의 허점 및 반례를 생각해보는 연습이 필요할 것 같다.
* [연등] 백준-2170(sort) 완료 - 비효율적인 탐색이 있다면(순차탐색 등) 정렬의 이점을 활용해 시간 복잡도를 줄이자. 또 정렬 후의 특성을 이용해 논리를 잘 구성해 해결하자.
* [연등] 백준-2230(sort) 완료 - 투 포인터의 여러 활용 방법을 익히자. (-> <- , -> ->)
### 22/8/18
* 백준-2208(bfs) 완료 - 벽을 뚫고 방문한 경우와 벽을 뚫지 않고 방문한 경우를 나눠서 한 리스트에 0,1,2 로 구분했는데, 그러니 충돌 자체는 안나서 답은 올바르게 나오지만 불필요한 큐가 계속 생겨 시간 복잡도를 늘렸다. 따라서 각 경우의 방문 리스트를 두개로 만들어서 처리하니 잘 통과되었다.
* [연등] 백준-2470(sort) 완료 - 처음엔 어떻게 풀어야 하나 난감했는데, 정렬된 리스트를 기반으로 투 포인터를 이용해 비교하니 쉽고 빠르게 풀렸다!
### 22/8/17
* 1987번은 충분히 학습한 것 같으니 다음 문제를 풀어보자.
* 백준-2206(bfs) 시도 - 벽을 뚫고 방문한 경우와 벽을 뚫지 않고 방문한 경우가 충돌하는데, 이를 해결할 시간이 부족하다. 다음에 계속 방법을 고민해보자.
### 22/8/16
* 오늘은 내 생일이다. 근데도 아직 격리구나.
### 22/8/15
* 코로나 유증상으로 격리돼서 사지방을 이용할 수 없어 코딩 연습을 하지 못했다..
### 22/8/14
* 백준-1987(dfs) 시도 - 와.. 몇시간을 붙들어도 안풀린다. python3는 시간초과, pypy3는 메모리 초과.. 메모리를 희생해 계속 시간 최적화를 해보아도 파이썬에서 시간초과가 뜬다. 계속 붙들고 답까지 가보자.
* [연등] 백준-1987(dfs) 완료 - setrecursionlimit의 크기만큼 메모리를 미리 잡아먹는다는 사실을 간과했다. 그 값을 줄이니 pypy3에서 메모리초과가 안뜨고 성공했다. 계속 최적화시켜서 python3로도 빠르게 돌아가도록 해보아야겠다.
* [연등] 백준-1987(dfs/bfs) 최적화 완료 - DFS, BFS 모두로도 풀 수 있었으며 최종적으로 bfs로 python3에서 성공했다. ★ 그보다 정말 중요한건, set이 굉장히 빠른 자료형이라는 것이다. BFS로 풀었을때에도 오래걸린 이유가 중복된 작업이 계속 큐에 들어가서 진행되었기 때문인데, 큐로서 set을 사용하면 랜덤으로 큐에서 나온다는 것만 제외하면 (큐에서 나오는 순서가 중요하지 않다면) hash를 사용하는 set 특성상 O(1)의 속도로 중복여부를 체크해서 불필요한 중복작업의 push/pop을 막아주고, 나머지는 deque와 동일하게 push 및 pop 도 O(1)로 빠르게 처리 가능하다. 정리: BFS+큐 순서X+중복큐 제거 -> set() ★
* [연등] 백준-1987(dfs/bfs) 추가 공부 - 특이하게, set을 이용해서 python3에서 2초 가량 걸리던 코드가 pypy3에선 9초 이상의 시간이 걸려 시간초과가 난다. 그리고 set의 사용 조건에서 큐의 순환을 카운팅하지 않아야한다는 조건이 있어야 한다고 적었는데 그건 아니었다. ex) while Q: ... count+=1 for _ in range(len(Q)): ...  도 가능. 그리고 deque로 set의 기능을 구현해서 중복작업을 O(1)로 안하게 만들면서 들어간 순서대로 큐가 나오게 시도해보고 있다. 시간이 없어서 다음에 해보자.
### 22/8/13
* 백준-14502(dfs) 완료 - 문제 조건을 잘 못 이해해서 삽질했다. 쓸데없었던 부분을 없애고 코드 보완해주니 의외로 쉽게 통과했다.
* 백준-1987(dfs) 시도 - 문제가 간단한 건줄 알았는데 의외로 시간복잡도에서 난관에 부딪혔다. 관련 알고리즘으로 백트래킹이 있는데 생소한 개념인만큼 공부해서 다시 풀어보도록 하자.
### 22/8/12
* 백준-2668(dfs) 완료 - 그래프에서의 loop를 찾는 것이 핵심이었다. 짜면서도 이게 맞는건가 싶었지만.. 그래프 이론을 코드로 표현하는 방법을 잘 이해해보아야 겠다.)
* [연등] 백준-6593(bfs) 완료 - 매우 간단한 bfs 문제라 쉽게 풀었다. 근데 귀찮은 조건문이 코드를 길고 가독성 낮게 만들었다..
* [연등] 백준-14502(bfs/dfs) 시도 - 난이도가 역시 gold4 여서 그런지 구현이 좀 복잡한 것 같다. 시간이 부족하니 다음에 계속 이어서 해보자.
### 22/8/11
* 백준-2251(bfs) 완료 - 방문 처리를 인덱스 접근 방식이 아닌 if ~ in 체크로 했는데도 시간초과는 커녕 매우 빠르게 통과됐다! 문제 조건이 살짝 난해하긴 했지만, 이해하니 쉽게 해결했다.
### 22/8/10
* 백준-16928(bfs) 완료 - 굉장히 쉽고 빠르고 정확하게 풀었다. bfs를 열심히 푼 성과가 보이는 것 같다!
* [연등] 백준-13023(dfs) 완료 - 그래프 탐색은 무작위 루프 탐색이 아닌 list[a] = b 방식으로 표현하면 훨씬 시간 복잡도를 줄일 수 있다! 잘 기억하자.
* [연등] 백준-2251(bfs/dfs) 시도 - 계산식이 조금 헷갈린다. 시간적 여유를 두고 다음에 다시 풀어보자.
### 22/8/9
* 백준-1068(bfs) 완료 - 문제를 완전히 잘못 이해하고 있었다. 이진 트리도 아닌데.. 제대로 이해하고 나니 쉽고 빠르게 풀 수 있었다. 풀기는 bfs로 풀었지만 충분히 dfs로도 풀 수 있을 것 같다. 그리고 새로운 트리 표현 방식을 알게 되었다. 조금 복잡하긴 하지만 잘 유념하고 있어야겠다.
### 22/8/8
* 백준-1068(bfs) 시도 - 트리가 왜 갑자기 어렵게 느껴질까.. 이론은 잘 알고 있는데 응용이 잘 안된다.
### 22/8/7
* 백준-5014(bfs) 완료 - 리스트 길이를 늘리니 해결..
* 백준-2589(bfs) 완료 - 삽질을 좀 했지만 해결. "방문 처리는 큐에서 꺼낼 때가 아니라 큐에 넣을 때!!"
### 22/8/6
* 백준-16234(bfs/dfs) 완료 - pypy3는 통과, python3 는 50ms 차이로 성공했는데, bfs로 푸는게 효율적인 문제를 dfs로 풀어서 그런 것 같다..
* [연등] 백준-2468(dfs) 완료 - 단순한 dfs문제로 쉽게 풀었다.
* [연등] 백준-5014(bfs) 시도 - 이상한 인덱스 에러가 뜬다. 시간이 없으니 원인 찾기와 해결은 내일 해보자..
### 22/8/5
* 오늘은 즐겁게 놀고 먹은 날! 공부도 하루 휴업~
### 22/8/4
* 백준-10026(dfs/bfs) 시도 - 시간이 없어서 진행을 못했다. 연등 때 이어서 해보아야겠다.
* [연등] 백준-10026(bfs) 완료 - 어려운 건 딱히 없었는데 재귀 깊이 설정 때문에 혹시 틀렸나 걱정했다. sys.setrecursionlimit(n) 을 잘 기억하자.
* [연등] 백준-7569(bfs) 완료 - 7576의 3차원 버전이다. 기존 코드 수정해서 빠르고 쉽게 해결했다!
* [연등] 백준-16234(bfs/dfs) 시도 - 문제 조건이 다소 복잡하여 구현하는데 시간이 부족했다. 그룹을 짜는 건 완료했지만 그 후 이동시간을 계산하는 건 다음에 다시 시도해 보아야겠다..
### 22/8/3
* 백준-7576(bfs) 완료 - deque의 queue를 사용하니 쓸데 없는 루프가 사라져 시간복잡도가 많이 줄어서 성공했다. bfs의 핵심을 잘 기억하자..
### 22/8/2
* [연등] 백준-7576(bfs) 시도 - 시간복잡도가 매우 큰 듯 하다. bfs이니 deque의 queue를 사용해서 최적화를 해보자..
### 22/8/1
* [연등] 백준-14503(implementation) 완료 - 조건이 구체적으로 나와있어 구현하기에 쉬웠다.
* [연등] 백준-2667(dfs) 완료 - 간만에 해보는 dfs이지만 생각만큼 어렵지 않았다.! 다음엔 바로 골드 풀어도 될 듯
### 22/7/31
* 백준-16926(implementation) 최적화 완료 - rotate를 이용하여 swap 및 회전의 반복을 줄이니 시간 복잡도가 상당량 줄어들었다. 회전시킬 테두리를 일차원 리스트로 만들어서 rotate 시키는게 핵심.
* 백준-2564(implementation) 완료 - 삽질을 너무 많이 했다.. 근데 내가 했던 것 처럼 테두리를 일자로 펴서 구하는 아이디어는 흔치 않은 듯??
### 22/7/30
* 백준-16926(implementation) 완료 - 구현 문제에 많이 약한 것 같다. 돌이켜보면 그렇게 어려운 로직은 아닌데, 시간복잡도를 줄이는 데에 시간을 많이 허비했다. 연등시간에 시간복잡도를 더 줄여봐야겠다. 5초 제한 시간인데 4.956초로 해결했다..
* [연등] 백준-13335(implementation) 완료 - 생각보다 어렵지 않게(?) 해결한 것 같다. 문법에서 조금 삽질을 했으니 이부분만 보완을 하면 될 듯..
* [연등] 백준-16926(implementation) 최적화 시도 - 시간복잡도를 거의 못줄였다. 다음번엔 queue 의 rotate 메소드를 이용해봐야겠다..
### 22/7/29
* [휴가] 휴가 복귀했다.. 연등 할 수 있으면 그 때 마저 2504번을 해결해 보아야겠다.
* [연등] 백준-2504(implementation) 완료 - 역대급으로 복잡했던(?) 문제였다.. stack 사용으로 시간 복잡도를 줄이고, 타입 검사등으로 스택에 덧셈 곱셈 숫자 정보를 잘 푸쉬하고 여러 경우의 수를 고려해 값을 정리하는 테크닉이 좀 필요하다. 꼭 다음에 다시 한 번 풀어봐야지..
### 22/7/28
* [휴가] 휴식
### 22/7/27
* [휴가] 백준-2504(implementation) 시도 - 좀 어렵다..
### 22/7/26
* [휴가] 백준-2504(implementation) 시도 - 답 자체는 잘 나오지만 시간 복잡도가 큰 것 같다. 다음에는 스택을 활용해보자.
### 22/7/25
* [휴가] 백준-2504(implementation) 시도 - 이산수학 시간에 배웠던 것 같은데 조금 가물가물 한 것 같다. 복습을 해보아야겠다.
### 22/7/24
* 휴가 준비로 인해 바빠서 개인정비 시간동안 풀지 못했다.. 내일은 기다리던 첫 휴가
* [연등] 백준-2615(implementation) 완료 - 조건이 다양하다보니 사소한 잔실수가 너무 많다. 디버깅 확실히 하자..
* [연등] 백준-1713(implementation) 완료 - EZ
* (백준 코테 단골 유형 실버 문제집 : https://www.philgineer.com/2021/11/codingtest-selection.html)
* [연등] 백준-10997(implementation) 완료 - 규칙만 잘 찾으면 큰 어려움 없이 풀 수 있었다.
### 22/7/23
* 백준-15686(implementation) 시도 - 정확한 구현을 못하겠다. 실력을 많이 쌓고 다음 기회에 재도전 하자..
* [연등] 백준-1138(implementation) 완료 - itertools의 사용법만 잘 알면 쉽게 풀 수 있다.
* [연등] 백준-2615(implementation) 시도 - 꽤 조건이 복잡한 것 같다. 시간이 부족하므로.. 다음에 else 부분 부터 수정 들어가자.
### 22/7/22
* 백준-18111(implementation) 시도 - 시간이 없어서 마무리를 못했다. 연등때 마무리 하기로!
* (22/7/20 에 "백준-15686(implementation)"이 "백준-15686(greedy)"로 잘못 적혀있어 수정)
* [연등] 백준-18111(implementation) 시도 - 문제 접근 방법을 잘 모르겠다. 다음에 다시 해보자.
* [연등] 백준-10773(implementation) 완료
* [연등] 백준-18111(implementation) 완료 - 잔 실수가 굉장히 많았다. 코드를 확실하게 짜자..
### 22/7/21
* 오늘 신병이 들어와서 너무 바빴다. 정신 읎서..
### 22/7/20
* [연등] 백준-15686(implementation) 시도 - 논리를 제대로 생각하지 않고 무작정 풀려고 한게 문제인 것 같다. 좀 더 간단한 논리를 차근차근 생각해보고 코드로 옮겨보자.
### 22/7/19
* 백준-1083(greedy) 완료 - 문제의 조건을 너무 어렵게 생각했다. 논리를 꼼꼼하게 정리하여 어떤 조건을 걸어야 하는지 차분하게 생각해보자.
* [연등] 백준-19940(greedy) 완료 - 상황 별 진행 순서를 명확하고 체계적으로 짜자. 루프돌며 1씩 더하거나 빼는게 아닌 몫계산으로 시간복잡도를 낮춤.
* 다음 계획: 내일부턴 구현(implementation) 연습을 해보자.
### 22/7/18
* 야간 사격 훈련으로 인해 할 시간이 없다.
### 22/7/17
* 백준-1461(greedy) 완료 - 조건이 의외로 까다로워 구현에 애를 먹었다. 일반화를 더 꼼꼼히 하고 반례를 열심히 찾자.
* 백준-13164(greedy) 완료 - 열심히 푼 성과가 보인다. 내용은 다르지만 2212번과 요구하는 사항이 동일하다는 걸 깨닫고 바로 풀었다!
* 백준-19539(greedy) 완료 - 아이디어를 생각하기 어려운 문제였다. 나중에 다시 한 번 깊게 생각해보자.
* 백준-11509(greedy) 완료 - 시간복잡도를 낮추는 방안을 여러가지 생각해보자. (heap 등도 있지만 한개 한개의 절차 대신 연속으로 진행시키는 시도 -> 시간복잡도의 차수가 낮아진다.)
* [연등] 백준-1374(greedy) 완료 - 11000과 동일한 문제다
* [연등] 백준-1083(greedy) 시도 - 루프 조건이 좀 까다로우니 신경써서 해보자.
### 22/7/16
* 백준-11000(greedy) 완료 - heap 응용을 통한 시간 복잡도 낮추기.
* (22/7/14의 1946은 import sys ; sys.stdin.readline() 이 핵심)
* 백준-2212(greedy) 완료 - 확률과 통계 문제처럼 전체구간에서 필요없는 구간의 최대값을 이용하여 필요한 구간의 최소값을 구하는 테크닉 이용. (≒여집합?)
* 백준-12904(greedy) 완료 - 제시된 대로가 아닌, 생각을 뒤집는 발상의 전환 필요
* 백준-1041(greedy) 완료 - 일반화만 잘하면 의외로 쉽다.
* 백준-1092(greedy) 시도 - 시간 복잡도를 줄이는 노력을 해보자.
* [연등]백준-1092(greedy) 완료 - 정렬된 데이터에서 무의미한 검색을 줄이는게 핵심!
* [연등]백준-1461(greedy) 시도 - 구현이 복잡하여 일부 예제에서 오답이 나온다. 다음시간에 꼼꼼하게 체크하자!
### 22/7/15
* 백준-11000(greedy) 시도
* 골드 아니랄까봐 난이도가 갑자기 어려워졌다. 시간 복잡도를 줄이는 노력을 해보자.
### 22/7/14
* 백준-2839(greedy) 완료
* [연등] 백준-11399(greedy), 백준-11047(greedy), 백준-1931(greedy), 백준-1946(greedy) 완료
### 22/7/13
* DFS/BFS 학습 시작  (5-3 음료수 얼려 먹기까지 완료)
* 연등으로 추가 학습 시작(DFS/BFS 학습 완료)
* 다음 계획: https://www.acmicpc.net/problem/tags 에서 greedy, implementation, DFS/BFS 복습하기
### 22/7/12
* DFS/BFS 및 인접 행렬, 인접 리스트 등 그래프 관련 이론 학습 완료
### 22/7/11
* 구현(implementation) 학습 시작(4-3 왕실의 나이트까지 완료)
* 연등으로 추가 학습 시작(implementation 학습 완료)
### 22/7/10
* replit 연동 후 '이것이 취업을 위한 코딩테스트다 with 파이썬'으로 학습 시작
* greedy 학습 완료